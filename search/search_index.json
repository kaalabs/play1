{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Domobar Control System","text":"<p>Safety-first, decentralized control for the VBM Domobar Classic / Standard (RVS), built on ESP32 with MicroPython.</p> <ul> <li>Start with the Architecture and Safety pages to understand the design principles.</li> <li>Use Hardware and Bring-up to wire and validate the system.</li> <li>Maintenance and Troubleshooting cover field service.</li> <li>The Developer Guide explains contributing and test practices.</li> </ul>"},{"location":"architecture/","title":"Architecture Overview","text":"<ul> <li>Decentralized autonomous nodes using ESP32-WROOM-32E:</li> <li>Boiler node: heater control via thermistor-derived steam pressure, interlocked with autofill.</li> <li>Autofill node: boiler level probe and solenoid control; rate limits and timeout latch.</li> <li>Pump/brew node: brew switch input, pump actuation with run-time/min-rest limits and starts-per-minute limiting.</li> <li>Optional Master (ESP32-S3): orchestration and UX; never compromises core safety.</li> <li>Language: MicroPython on device. Control logic is CPython-testable.</li> </ul>"},{"location":"architecture/#master-node-services-non-safety-critical","title":"Master Node Services (non-safety-critical)","text":"<ul> <li>Tank Service (<code>firmware/master/tank_service.py</code>)</li> <li>UART driver for DYP-A02YYUW ultrasonic sensor (<code>firmware/core/tank_sensor.py</code>).</li> <li>Hysteresis-based alerts (ok/low/critical).</li> <li> <p>Line-based RPC: <code>get_level</code> -&gt; <code>{ level_pct, state }</code>.</p> </li> <li> <p>Scale Service (<code>firmware/master/scale_service.py</code>)</p> </li> <li>Unified BLE protocol adapter for BooKoo and Half Decent (<code>firmware/master/scale_adapter.py</code>).</li> <li>Decoders: <code>scale_bookoo.py</code> and <code>scale_halfdecent.py</code> (UUIDs, frames, commands).</li> <li>Exponential smoothing, stability debounce, and derived flow (g/s).</li> <li> <p>Line-based RPC: <code>get_weight</code> -&gt; <code>{ weight_g, flow_gps, stable, source }</code>, <code>tare</code> -&gt; hex command.</p> </li> <li> <p>Aggregator (<code>firmware/master/aggregator_service.py</code>, <code>aggregator_rpc.py</code>)</p> </li> <li>Composes tank + scale into one dashboard payload: <code>{ tank:{...}, scale:{...} }</code>.</li> <li>RPC: <code>get_status</code> for a single-shot combined view.</li> </ul> <p>Notes:</p> <ul> <li>Master logic is advisory and never gates safety. Core nodes must reach safe states independently.</li> <li>BLE client scaffolding is optional; a fake notifier/runner is provided for local development.</li> </ul>"},{"location":"architecture/#module-boundaries","title":"Module Boundaries","text":"<ul> <li>Core nodes must be safe standalone: safe-off on fault, watchdog, plausibility checks.</li> <li>Inter-node signaling is advisory (e.g., autofill active) and must never be a single point of failure.</li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<ul> <li>Inputs: NTC thermistor (boiler), level probe, brew switch; optional pressure transducer; ultrasonic tank level (DYP-A02YYUW) on master.</li> <li> <p>Outputs: heater SSR/relay, pump, fill solenoid; optional indicators.</p> </li> <li> <p>Master inputs: BLE notifications from supported scales; UART frames from tank sensor.</p> </li> <li>Master outputs: UX state/JSON over serial or network; BLE write commands (e.g., tare) via adapters.</li> </ul>"},{"location":"architecture/#hal-strategy","title":"HAL Strategy","text":"<ul> <li><code>hal_mpy.py</code> provides GPIO/ADC access for MicroPython and degrades gracefully under CPython for tests.</li> <li>A minimal stub HAL exists for tests without MicroPython.</li> </ul>"},{"location":"architecture/#control-laws","title":"Control Laws","text":"<ul> <li>Boiler: hysteresis on estimated steam pressure; configurable via <code>BoilerConfig</code>.</li> <li>Autofill: edge-triggered fill with timeout and min-interval rate limiting.</li> <li>Pump: command-following with safety: max run time, min rest, starts-per-minute limit.</li> </ul>"},{"location":"architecture/#future-extensions","title":"Future Extensions","text":"<ul> <li>PID or adaptive control (only if it adds value without compromising safety).</li> <li>Profiled brewing (requires additional sensors/UX; lives on master node).</li> <li>Extended UX: graphical dashboards, calibration tooling, and persisted logs.</li> </ul>"},{"location":"bringup/","title":"First Bring-up and Calibration","text":"<p>Prereqs:</p> <ul> <li>MicroPython flashed on ESP32 nodes</li> <li>Verified wiring per hardware guide</li> <li>Python env ready for tests</li> </ul>"},{"location":"bringup/#steps","title":"Steps","text":"<ol> <li>Configure pins and thermistor parameters in <code>firmware/common/config.py</code>.</li> <li>Unit-test locally: <code>pytest -q</code>.</li> <li>Deploy to boiler node: copy <code>firmware/common</code> and <code>firmware/core</code> (including <code>boot_boiler.py</code>) to the ESP32.</li> <li>Power on with heater physically disconnected for the first run. Observe temp reading via UART/debug prints if added.</li> <li>Verify thermistor reading rises with gentle heat. Adjust <code>ThermistorConfig</code> if needed.</li> <li>Connect heater through SSR and perform low-duty test: set target to low pressure/temp, confirm hysteresis behavior and safe-off on faults.</li> <li>Pump node: verify pump toggles with brew switch input. Confirm min rest inhibit and that run-time timeout trips a fault as expected.</li> </ol>"},{"location":"bringup/#rs485-bus-bring-up","title":"RS485 Bus Bring-up","text":"<ol> <li>Wire RS485 A/B daisy-chain with 120 \u03a9 terminators at both ends and a single bias point.</li> <li>Configure <code>Pins.rs485_*</code> and <code>BusConfig</code> in <code>firmware/common/config.py</code> (baud/address).</li> <li>Power nodes and connect your USB-RS485 adapter to the PC. Note the serial port path (e.g., <code>/dev/tty.usbserial-1101</code>).</li> <li>In VS Code, run the task \"Modbus snapshot (aggregator CLI)\" and enter the serial port. You should see JSON with status/reason codes.</li> <li>Sanity checks:<ul> <li>Disconnect one node: its section should time out or show zeros; reconnect and verify it reappears.</li> <li>Toggle brew switch or lift the boiler level probe and observe status/reason changes.</li> <li>If no responses, verify DE polarity and that only the master is driving the bus when transmitting.</li> </ul> </li> <li>Optional: run \"Modbus probe (single read)\" to query a specific node/address and registers for quick checks during wiring.</li> </ol>"},{"location":"bringup/#calibration-optional","title":"Calibration (optional)","text":"<ul> <li>Compare estimated pressure (from temp) against an external gauge or relief-valve lift.</li> <li>If using a pressure transducer, record raw ADC and actual pressure points and update the mapping in HAL.</li> </ul>"},{"location":"calibration/","title":"Calibration Guide","text":"<p>This guide helps you calibrate sensor readings to the Domobar Classic/Standard.</p>"},{"location":"calibration/#thermistor-temperature-pressure","title":"Thermistor (temperature -&gt; pressure)","text":"<ul> <li>Ensure good thermal coupling and insulation of the NTC to the boiler shell.</li> <li>With machine at steady state, record:</li> <li>NTC ADC counts and computed temperature</li> <li>Observed steam pressure (external gauge or relief onset)</li> <li>Adjust the temperature-to-pressure mapping if systematic bias is observed.</li> <li>Option A: tweak Antoine coefficients in <code>HAL.steam_pressure_from_temp_c</code>.</li> <li>Option B: implement a simple 2\u20133 point linearization table.</li> </ul>"},{"location":"calibration/#pressure-transducer-optional","title":"Pressure Transducer (optional)","text":"<ul> <li>Record ADC counts at known pressures (0 bar, ~1 bar, ~2 bar) using a reference gauge.</li> <li>Fit a line and update the mapping in <code>HAL.read_pressure_bar</code> (v_min/v_max/bar_max and divider).</li> </ul>"},{"location":"calibration/#linearization-helper","title":"Linearization helper","text":"<p>You can apply a simple piecewise-linear mapping using <code>firmware/common/utils.py</code>:</p> <ul> <li>Collect 2\u20133 calibration points (e.g., temperature -&gt; pressure or ADC -&gt; bar).</li> <li>Build a <code>Linearizer([(x0, y0), (x1, y1), (x2, y2)])</code> and use it to map raw to engineering units.</li> <li>For MicroPython deployment, precompute points and embed them in config.</li> </ul>"},{"location":"developer_guide/","title":"Developer Guide &amp; Contribution","text":""},{"location":"developer_guide/#project-layout","title":"Project Layout","text":"<ul> <li><code>firmware/common</code>: shared config and safety primitives</li> <li><code>firmware/core</code>: autonomous node controllers and HALs</li> <li><code>firmware/core/tank_monitor.py</code>: local tank level state machine (ok/low/critical/unknown)</li> <li><code>tests</code>: CPython unit tests for core logic</li> <li><code>docs</code>: documentation set</li> </ul>"},{"location":"developer_guide/#local-dev","title":"Local Dev","text":"<ul> <li>Python 3.11+ recommended for tests</li> <li>Create venv, <code>pip install -r requirements.txt</code>, run <code>pytest -q</code></li> </ul>"},{"location":"developer_guide/#master-side-helpers","title":"Master-side helpers","text":"<ul> <li>Scale smoke test: use VS Code task \"Scale smoke (fake BLE)\" to stream demo frames into the scale service and print JSON.</li> <li>Aggregator RPC: use the \"Aggregator RPC (stdin/stdout)\" task, and send <code>get_status</code> on stdin to receive combined tank + scale status.</li> <li>Real BLE (desktop): optional bleak scaffold exists in <code>firmware/master/ble_client.py</code> (not a hard dependency). Wire your notify callback to <code>ScaleService.on_notify()</code>.</li> <li>BLE Bridge (desktop): <code>firmware/master/ble_bridge.py</code> provides a ready-to-run bleak bridge. Try the VS Code task \"BLE Bridge (desktop, bleak)\" or run it manually with <code>--source bookoo|halfdecent</code> and either <code>--address</code> or <code>--name</code>.</li> </ul>"},{"location":"developer_guide/#logging","title":"Logging","text":"<ul> <li>Convert readings to CSV: pipe JSON lines into <code>tools/scale_logger.py -o out.csv</code>.</li> <li>VS Code task: \"Scale -&gt; CSV (fake stream)\" pipes the demo runner into the CSV logger and writes <code>/tmp/scale.csv</code>.</li> <li>VS Code task: \"BLE Live -&gt; CSV (bridge)\" pipes the bleak-based bridge into the CSV logger to capture real sessions at <code>/tmp/scale_live.csv</code>.</li> </ul>"},{"location":"developer_guide/#coding-standards","title":"Coding Standards","text":"<ul> <li>Favor pure-Python logic for testability; isolate MicroPython APIs in HAL.</li> <li>Keep core safety behaviors covered by tests.</li> <li>Update docs with any behavior or interface change.</li> </ul>"},{"location":"developer_guide/#adding-a-feature","title":"Adding a Feature","text":"<ol> <li>Propose design if it touches core behaviors/safety.</li> <li>Add or update tests (happy path + edge/fault cases).</li> <li>Implement feature with minimal HAL surface.</li> <li>Update docs: architecture, safety (if relevant), bring-up, troubleshooting.</li> <li>Update <code>CHANGELOG.md</code>.</li> </ol>"},{"location":"developer_guide/#tank-autonomy-refactor","title":"Tank autonomy refactor","text":"<ul> <li>The tank sensor is now owned by core via <code>TankMonitor</code>, which wraps <code>TankLevel</code> and applies hysteresis.</li> <li>Controllers accept a new <code>tank_ok</code> parameter:<ul> <li><code>AutofillController.tick(..., tank_ok=True)</code> inhibits fill if false.</li> <li><code>PumpController.tick(..., tank_ok=True)</code> inhibits pump if false.</li> </ul> </li> <li>Main loops updated:<ul> <li><code>boot_autofill.py</code> samples <code>TankMonitor</code> each cycle and passes <code>tank_ok</code>.</li> <li><code>boot_pump.py</code> does the same for the pump node.</li> </ul> </li> <li>The master <code>tank_service.py</code> remains for UX/telemetry but is no longer required for safety.</li> </ul>"},{"location":"developer_guide/#release-deployment","title":"Release &amp; Deployment","text":"<ul> <li>Tag changes and record in <code>CHANGELOG.md</code>.</li> <li>Deploy node-specific files to devices via <code>mpremote</code>/<code>rshell</code>.</li> </ul>"},{"location":"developer_guide/#rs485-modbus-helpers","title":"RS485 / Modbus helpers","text":"<ul> <li>Snapshot registers from nodes over RS485: use the VS Code task \"Modbus snapshot (aggregator CLI)\" and provide your serial port (e.g., <code>/dev/tty.usbserial-1101</code>). It prints a one-line JSON of pump, autofill, and boiler status. Requires <code>pyserial</code> at runtime.</li> </ul> <p>Register map (Holding Registers 0x03):</p> <ul> <li>0x0000: status code</li> <li>0x0001: reason code</li> <li>0x0002: tank_ok (0/1; pump/autofill only)</li> <li>0x0003: reserved</li> </ul> <p>Node addresses (default): pump=1, autofill=2, boiler=3, master=10. See <code>firmware/common/config.py</code> BusConfig.</p> <p>Status/Reason codes:</p> <ul> <li>Pump<ul> <li>status: 0=idle, 1=run, 2=inhibit, 3=fault</li> <li>reason: 0=none, 1=rest, 2=rate_limit, 3=tank_not_ok, 4=watchdog_expired, 5=pump_run_timeout</li> </ul> </li> <li>Autofill<ul> <li>status: 0=ok, 1=fill, 2=inhibit, 3=fault</li> <li>reason: 0=none, 1=rate_limit, 2=tank_not_ok, 3=fill_timeout, 4=watchdog_expired</li> </ul> </li> <li>Boiler<ul> <li>status: 0=idle, 1=heat/hold, 2=inhibit, 3=fault</li> <li>reason: 0=none, 1=autofill, 2=sensor_out_of_range, 3=heater_on_timeout, 4=watchdog_expired</li> </ul> </li> </ul>"},{"location":"hardware/","title":"Hardware Wiring and Components","text":"<p>Warning: Mains voltage is lethal. Only qualified personnel should service or modify wiring. Always disconnect power and verify.</p>"},{"location":"hardware/#mcu-selection","title":"MCU Selection","text":"<ul> <li>ESP32-WROOM-32E for core nodes, ESP32-S3 for master UX.</li> </ul>"},{"location":"hardware/#sensors","title":"Sensors","text":"<ul> <li>Boiler thermistor: 100k NTC (Beta ~3950) bonded to boiler shell; divider with 100k pull-up to 3.3V.</li> <li>Level probe: digital via conditioner (optocoupler/AC sensing) preferred.</li> <li>Optional pressure transducer: 0.5\u20134.5V ratiometric with divider and filtering.</li> <li>Tank level (DYP-A02YYUW ultrasonic, on master): 5V supply, TTL UART 9600-8N1. Mount on tank lid facing water; ensure clear path and avoid splashes/condensation. Use level shifting or 5V-tolerant UART as needed.</li> </ul>"},{"location":"hardware/#actuators","title":"Actuators","text":"<ul> <li>Heater SSR/relay rated for 1.4 kW at mains; zero-cross SSR preferred.</li> <li>Fill solenoid driver: opto-isolated triac or relay module.</li> <li>Pump driver: relay/SSR with surge handling.</li> </ul>"},{"location":"hardware/#grounding-and-isolation","title":"Grounding and Isolation","text":"<ul> <li>Maintain protective earth to chassis and group head.</li> <li>Ensure control ground is isolated from mains where necessary; use proper opto/isolation barriers.</li> </ul>"},{"location":"hardware/#rs485-modbus-rtu-wiring","title":"RS485 (Modbus RTU) Wiring","text":"<ul> <li>Use a differential RS485 transceiver (e.g., MAX485, SN75176) on each node.</li> <li>Bus topology: multi-drop A/B twisted pair; daisy-chain preferred; avoid stubs.</li> <li>Termination: 120 \u03a9 across A/B at the two physical ends of the bus only.</li> <li>Biasing: one location should provide fail-safe bias (e.g., 680 \u03a9\u20131 k\u03a9 pull-up on A, pull-down on B) so the bus idles HIGH/mark.</li> <li>DE/RE handling: tie RE low (enable receiver) and drive DE high only during TX. Our firmware toggles a dedicated <code>rs485_de</code> GPIO around UART writes.</li> <li>UART: 9600 8N1 by default; ensure all nodes share baud rate. Wire UART TX/RX to DI/RO on the transceiver.</li> <li>Shielding: use shielded twisted pair if noise is present; connect shield to earth at one point only.</li> </ul>"},{"location":"hardware/#wiring-matrix-typical-transceiver","title":"Wiring matrix (typical transceiver)","text":"Function RS485 transceiver pin Connects to Notes UART TX DI MCU UART TX (see <code>Pins.rs485_tx</code>) MCU drives DI; goes out on bus UART RX RO MCU UART RX (see <code>Pins.rs485_rx</code>) Transceiver drives RO to MCU Driver enable DE MCU GPIO (see <code>Pins.rs485_de</code>) High during TX only Receiver enable RE Tie to DE or GND (active low) Tie to DE for auto half-duplex, or GND to always listen Bus A A (a.k.a. D+) RS485 bus A Keep A-to-A across all nodes Bus B B (a.k.a. D\u2212) RS485 bus B Keep B-to-B across all nodes Power VCC 3.3 V or 5 V per transceiver Ensure logic-level compatibility with MCU Ground GND Common ground Required reference between nodes <p>Notes:</p> <ul> <li>Some boards label A/B inverted (D+/D\u2212). If the bus idles low or you see framing errors, swap A/B on that device.</li> <li>Many MAX485 modules are 5 V. They typically accept 3.3 V logic on DI ( VIH \u2248 2.0 V ), but verify your module; choose a 3.3 V variant or add level shifting if needed.</li> <li>USB\u2013RS485 adapters connect directly to the A/B pair; do not cross A\u2194B.</li> </ul>"},{"location":"hardware/#bus-topology-ascii","title":"Bus topology (ASCII)","text":"<pre><code>[PC USB\u2011RS485]--A/B--[Node 1]--A/B--[Node 2]--A/B--[Node 3]\n    |                                        |\n     120\u03a9                                     120\u03a9\n (terminator)                             (terminator)\n</code></pre> <ul> <li>Only the two physical ends of the bus are terminated (120 \u03a9 across A/B).</li> <li>Keep A-to-A and B-to-B throughout the chain; avoid long stubs.</li> <li>Provide fail-safe bias at one location so the line idles mark when idle.</li> </ul>"},{"location":"hardware/#troubleshooting","title":"Troubleshooting","text":"<ul> <li> <p>Continuous framing errors or no responses</p> <ul> <li>Likely cause: A/B swapped on one device</li> <li>Fix: Swap A and B on that device; keep A-to-A and B-to-B across the bus</li> </ul> </li> <li> <p>Works only when touching wires or only some nodes respond</p> <ul> <li>Likely cause: Missing termination or fail-safe bias</li> <li>Fix: Add 120 \u03a9 terminators at both physical ends; add a single bias point (pull-up on A, pull-down on B)</li> </ul> </li> <li> <p>Collisions or garbled replies with multiple nodes</p> <ul> <li>Likely cause: DE stuck high (driver always enabled) or more than one master</li> <li>Fix: Ensure firmware drives <code>rs485_de</code> high only while transmitting; ensure only one bus master</li> </ul> </li> <li> <p>Intermittent timeouts on longer runs</p> <ul> <li>Likely cause: Long stubs or noise coupling</li> <li>Fix: Shorten stubs, use twisted pair, add shielding, and ground shield at one end only</li> </ul> </li> <li> <p>Nodes reset when bus transmits</p> <ul> <li>Likely cause: Power/level issues (5 V transceiver with 3.3 V MCU) or poor decoupling/grounding</li> <li>Fix: Use 3.3 V-compatible transceivers or proper level shifting; add decoupling caps and ensure solid ground reference</li> </ul> </li> <li> <p>No data or gibberish at expected wiring</p> <ul> <li>Likely cause: Baud/parity mismatch</li> <li>Fix: Set all devices to <code>9600 8N1</code> (default) or update <code>BusConfig.baudrate</code> consistently</li> </ul> </li> </ul>"},{"location":"hardware/#quick-checks-meterscope","title":"Quick checks (meter/scope)","text":"<ul> <li> <p>Continuity</p> <ul> <li>Verify A-to-A and B-to-B continuity across all nodes; no A\u2194B cross anywhere</li> <li>Shield (if used) has continuity end-to-end but is grounded at one end only</li> </ul> </li> <li> <p>Termination</p> <ul> <li>Measure resistance between A and B with power off: \u2248120 \u03a9 at an end with one terminator; \u224860 \u03a9 across the full bus with two terminators</li> </ul> </li> <li> <p>Fail-safe bias (power on, idle)</p> <ul> <li>With bias present, A should be higher than B by roughly 0.2\u20131.5 V when idle (RO idles high/mark)</li> <li>Without bias, A\u2013B hovers near 0 V and the receiver may chatter</li> </ul> </li> <li> <p>DE/RE and RO behavior</p> <ul> <li><code>rs485_de</code> pin idles low; pulses high only during transmit frames</li> <li>MCU UART RX (RO) idles high (mark) and shows clean 9600 8N1 frames during traffic</li> </ul> </li> <li> <p>Baud and framing</p> <ul> <li>Confirm all devices use the same settings (default <code>9600 8N1</code>); a logic analyzer helps verify byte timing and CRC ordering</li> </ul> </li> </ul>"},{"location":"hardware/#pin-mapping-template","title":"Pin Mapping Template","text":"<p>Update <code>firmware/common/config.py</code>:</p> <ul> <li>heater_ssr: GPIOxx</li> <li>autofill_valve: GPIOxx</li> <li>pump: GPIOxx</li> <li>autofill_probe: GPIOxx (or ADC)</li> <li>boiler_temp_ain: ADC1_CHx</li> <li>tank_uart_id/tx/rx: UART id and pins for DYP-A02YYUW (master node)</li> </ul>"},{"location":"maintenance/","title":"Maintenance &amp; Service Procedures","text":"<p>Audience: trained maintenance engineers.</p>"},{"location":"maintenance/#safety","title":"Safety","text":"<ul> <li>Disconnect mains. Verify absence of voltage.</li> <li>Allow boiler to cool and depressurize before opening.</li> </ul>"},{"location":"maintenance/#periodic-checks","title":"Periodic Checks","text":"<ul> <li>Visual inspection of wiring, connectors, and chassis ground.</li> <li>Verify operation of factory safeties (thermostats, relief valve) per OEM guidance.</li> <li>Check SSR/relay modules for heat and proper mounting.</li> </ul>"},{"location":"maintenance/#service-actions","title":"Service Actions","text":"<ul> <li>Replacing thermistor: remove insulating wrap, clean contact, apply fresh thermal paste, rewrap.</li> <li>Replacing SSR/relay: match voltage/current rating; test with isolation.</li> <li>Updating firmware: redeploy <code>firmware/common</code> and node <code>firmware/core</code> files; verify setpoints.</li> </ul>"},{"location":"maintenance/#diagnostics","title":"Diagnostics","text":"<ul> <li>Fault latch reasons reported over UART/log (planned: LEDs or display on master).</li> <li>Use multimeter to verify probe, SSR outputs, and supply rails.</li> </ul>"},{"location":"master_ux/","title":"Master UX","text":"<p>The master node (ESP32-S3) provides user-facing information and controls, without impacting core safety.</p>"},{"location":"master_ux/#tank-level","title":"Tank Level","text":"<ul> <li>Reads DYP-A02YYUW ultrasonic sensor via UART (9600-8N1).</li> <li>Displays percent fill and a simple bar/graph.</li> <li>Alerts:</li> <li>Low: below <code>tank.low_pct</code> (with <code>hysteresis_pct</code>).</li> <li>Critical: below <code>tank.critical_pct</code>.</li> </ul>"},{"location":"master_ux/#prompts-and-actions","title":"Prompts and Actions","text":"<ul> <li>Low tank: show a non-blocking warning; suggest refill soon.</li> <li>Critical tank: prominent warning; optionally inhibit non-critical operations in the master UX only.</li> <li>Prime pump (maintenance): guided steps to prime the line after service; never bypasses core node safeties.</li> </ul>"},{"location":"master_ux/#integration","title":"Integration","text":"<ul> <li>RPC: master exposes <code>get_level</code> returning JSON <code>{ level_pct, state }</code> (see <code>firmware/master/tank_service.py</code>).</li> <li>RPC (scales): master provides <code>get_weight</code> returning <code>{ weight_g, flow_gps, stable, source }</code> and <code>tare</code> command that returns bytes as hex (see <code>firmware/master/scale_service.py</code>).</li> <li>RPC (aggregate): optional endpoint can return both tank and scale data: <code>{ tank:{level_pct,state}, scale:{weight_g,flow_gps,stable,source} }</code> (see <code>firmware/master/aggregator_service.py</code>).</li> <li>BLE Scales:</li> <li>BooKoo Themis/Mini: Service 0x0FFE, Data 0xFF11, Command 0xFF12. See <code>firmware/master/scale_bookoo.py</code>.</li> <li>Half Decent: Service <code>0000fff0-0000-1000-8000-00805f9b34fb</code>, Notify <code>0000fff4-0000-1000-8000-00805f9b34fb</code>, Write <code>000036f5-0000-1000-8000-00805f9b34fb</code>. See <code>firmware/master/scale_halfdecent.py</code>.</li> <li>Core nodes remain autonomous; UX is advisory.</li> </ul>"},{"location":"safety/","title":"Safety Case and Requirements","text":"<p>Principles:</p> <ol> <li>Hardware-first safety: retain factory safety chain (thermostats/thermal fuses/relief valves/pressurestat where applicable).</li> <li>Software adds secondary protections: watchdogs, latching faults, plausibility checks, timeouts, safe-off defaults.</li> <li>Decentralization: each core node must be safe if isolated from others.</li> <li>Non-invasive default: stock behavior unless advanced features are explicitly enabled.</li> </ol>"},{"location":"safety/#safety-functions","title":"Safety Functions","text":"<ul> <li>Boiler overheat/overpressure prevention via conservative setpoints and hysteresis.</li> <li>Heater inhibition during autofill.</li> <li>Fill timeout and min interval.</li> <li>Pump run-time limit and min rest (planned).</li> </ul>"},{"location":"safety/#fault-handling","title":"Fault Handling","text":"<ul> <li>Latching faults stop actuators until service action clears them.</li> <li>Fault reasons are retained and exposed via diagnostics.</li> </ul>"},{"location":"safety/#standards-and-practices","title":"Standards and Practices","text":"<ul> <li>Design aligns with IEC 60335-1/-2-15 concepts (household appliance safety).</li> <li>Electrical design to respect insulation, PE continuity, creepage/clearance, and EMC best practices.</li> <li>SSR/relay drivers shall provide isolation and snubbing as required by the load.</li> </ul>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Symptom -&gt; Checks:</p> <ul> <li>No heat: verify mains, SSR control pin, thermistor reading plausibility, latch status, factory thermostats.</li> <li>Rapid cycling: increase hysteresis or check thermistor bonding; verify SSR not sticking.</li> <li>Autofill never stops: probe signal stuck dry; check conditioner; see fill timeout fault.</li> <li>Frequent autofills: check reservoir level and probe conductivity; adjust min interval.</li> <li>Pump won\u2019t run: check brew switch debounce and pump driver; confirm run-time limit not tripping.</li> </ul> <p>Logs/Indicators:</p> <ul> <li>Planned: UART status lines from nodes; LED heartbeat patterns.</li> </ul>"}]}